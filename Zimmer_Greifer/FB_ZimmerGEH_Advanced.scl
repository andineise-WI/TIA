FUNCTION_BLOCK "FB_ZimmerGEH_Advanced"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      ip_Maschine : Int := 1;   // Maschinennummer
      ip_Station : Int;   // Stationsnummer
      ip_Bmk : String[30];   // Begleitwert als String
      i_StoerungQuittieren : Bool;   // Stoerung quittieren
      i_NotHalt                #ZimmerGEH_HMI.Ausgang.Status := 'Greifen - Parameter setzen';
                #ZimmerGEH_HMI.Ausgang.StepBusy := TRUE;
                #ZimmerGEH_HMI.Ausgang.StepDone := FALSE;
                
                // Parameter aus HMI-UDT uebernehmen
                #q_ZimmerGEH_PlcToDrv.DeviceMode := 62; // Innengreifen
                #q_ZimmerGEH_PlcToDrv.WorkpieceNo := 0; // Standardwertool;   // Steuerung Ein
      i_Sicherheitskreis_IO : Bool;   // Sich	     	                // Parameter aus HMI-UDT uebernehmen
	                #q_ZimmerGEH_PlcToDrv.DeviceMode := 63; // Aussengreifen (auch fuer Oeffnen)     0: // Parameter setzen fuer Loslassen
	                #ZimmerGEH_HMI.Ausgang.Status := 'Loslassen - Parameter setzen';heitskreis OK / Freigabe Greifer
      i_FreigabeBewegung : Bool;   // 1=Greifer darf verfahren/keine Kollision
      i_FreigabeHMI : Bool;   // 1=Freigabe fuer Bewegung ueber HMI
      i_ZimmerGEH_DrvToPlc : "ST_ZimmerGEH6000_DrvToPlc";   // Eingangsdaten vom Greifer
   END_VAR

   VAR_OUTPUT 
      q_ZimmerGEH_PlcToDrv : "ST_ZimmerGEH6000_PlcToDrv";   // Ausgangsdaten zum Greifer
      q_GripperReady : Bool;   // Greifer ist betriebsbereit
   END_VAR

   VAR_IN_OUT 
      ZimmerGEH_HMI : "ST_ZimmerGEH_HMI";   // HMI-Interface
      iq_Stoermeldeindikator { ExternalVisible := 'False'} : Bool;   // Stoermelder
   END_VAR

   VAR 
      power_on_state : Int;   // Status Motor ein/aus
      reference_state : Int;   // Status Referenzfahrt  
      grip_state : Int;   // Status Greifen
      release_state : Int;   // Status Loslassen
      error_state : Int;   // Fehlerstatus
      
      // Hilfsmerkbits
      hmPower_on : Bool;   // Motor ist eingeschaltet
      gripper_in_motion : Bool;   // Greifer in Bewegung
      hmReferenced : Bool;   // Greifer ist referenziert
      hmGripped : Bool;   // Werkstueck gegriffen
      
      // Alte Werte fuer Aenderungserkennung
      device_mode_old : Byte;
      workpiece_no_old : Byte;
      position_tolerance_old : Byte;
      grip_force_old : Byte;
      drive_velocity_old : Byte;
      base_position_old : UInt;
      work_position_old : UInt;
   END_VAR
   
   VAR DB_SPECIFIC
      // Timer entsprechend Original-Code
      ton_Timer_DataTransfer {InstructionName := 'TON'; LibVersion := '1.0'} : TON;
      ton_Timer_InMotion {InstructionName := 'TON'; LibVersion := '1.0'} : TON;
      wthDog {InstructionName := 'TON'; LibVersion := '1.0'} : TON;
      
      // R_TRIG fuer Flankenerkennung wie im Original
      rtrig_StartHoming {InstructionName := 'R_TRIG'; LibVersion := '1.0'} : R_TRIG;
      rtrig_DataTransfer {InstructionName := 'R_TRIG'; LibVersion := '1.0'} : R_TRIG;
      rtrig_MoveToBase {InstructionName := 'R_TRIG'; LibVersion := '1.0'} : R_TRIG;
      rtrig_MoveToWork {InstructionName := 'R_TRIG'; LibVersion := '1.0'} : R_TRIG;
   END_VAR
   
   VAR 
      iDB_BasisMappingProgramAlarm { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : "FB_BasisMappingProgramAlarm";
      Meldungen_ZimmerGEH {InstructionName := 'Program_Alarm'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : Program_Alarm;
   END_VAR

BEGIN
	(*
	version |   Datum   | Autor       | Kommentar
	--------|-----------|-------------|--------------------------------------------------
	v0.1    |10.09.2025 | w011247@WI  | Erste Erstellung nach Template basierend auf UDTs
	--------|-----------|-------------|--------------------------------------------------
	
	--- Kurzbeschreibung ---
	Schnittstellenbaustein fuer Zimmer GEH6000 Greifer.
	Funktionen: Motor ein/aus, Referenzfahrt, Werkstueck greifen/loslassen, Fehlerbehandlung
	
	--- Abhaengig von ---
	- ST_ZimmerGEH6000_DrvToPlc (Eingangstelegramm mit StatusWord Struct)
	- ST_ZimmerGEH6000_PlcToDrv (Ausgangstelegramm mit ControlWord INT) 
	- ST_ZimmerGEH_HMI (HMI-Schnittstelle mit Eingang/Ausgang Struct)
	- FB_BasisMappingProgramAlarm
	
	--- ControlWord-Werte (entsprechend Original-Code) ---
	0 = Idle/Kein Befehl
	1 = DataTransfer
	100 = MoveToBase
	200 = MoveToWork
	32768 = ErrorReset
	
	--- DeviceMode-Werte ---
	2 = Greifer-Reset
	3 = Motor ON
	10 = Standard Homing
	63 = Aussengreifen (sowohl fuer Greifen als auch Oeffnen/Loslassen)
	********************************************************************************)
	
	REGION Pruefung Parameteraenderungen
	    // Aenderungserkennung fuer DataTransferRequired basierend auf PlcToDrv-Struktur
	    IF #device_mode_old <> #q_ZimmerGEH_PlcToDrv.DeviceMode
	        OR #workpiece_no_old <> #q_ZimmerGEH_PlcToDrv.WorkpieceNo
	        OR #position_tolerance_old <> #q_ZimmerGEH_PlcToDrv.PositionTolerance
	        OR #grip_force_old <> #q_ZimmerGEH_PlcToDrv.GripForce
	        OR #drive_velocity_old <> #q_ZimmerGEH_PlcToDrv.DriveVelocity
	        OR #base_position_old <> #q_ZimmerGEH_PlcToDrv.BasePosition
	        OR #work_position_old <> #q_ZimmerGEH_PlcToDrv.WorkPosition
	    THEN
	        #ZimmerGEH_HMI.Ausgang.DataTransferRequired := TRUE;
	    END_IF;
	    
	    // Alte Werte speichern
	    #device_mode_old := #q_ZimmerGEH_PlcToDrv.DeviceMode;
	    #workpiece_no_old := #q_ZimmerGEH_PlcToDrv.WorkpieceNo;
	    #position_tolerance_old := #q_ZimmerGEH_PlcToDrv.PositionTolerance;
	    #grip_force_old := #q_ZimmerGEH_PlcToDrv.GripForce;
	    #drive_velocity_old := #q_ZimmerGEH_PlcToDrv.DriveVelocity;
	    #base_position_old := #q_ZimmerGEH_PlcToDrv.BasePosition;
	    #work_position_old := #q_ZimmerGEH_PlcToDrv.WorkPosition;
	END_REGION
	
	REGION Zeitueberwachungen
	    // Timer entsprechend Original-Code
	    #ton_Timer_DataTransfer(
	        IN := #q_ZimmerGEH_PlcToDrv.ControlWord = 1 
	              AND NOT #i_ZimmerGEH_DrvToPlc.StatusWord.DataTransferOK
	              AND #q_ZimmerGEH_PlcToDrv.DeviceMode <> 10, // Nicht waehrend Homing
	        PT := T#1s);
	    
	    #ton_Timer_InMotion(
	        IN := #gripper_in_motion,
	        PT := #ZimmerGEH_HMI.Eingang.MotionTimeout);
	    
	    // Timeout-Fehler setzen
	    IF #ton_Timer_DataTransfer.Q THEN
	        #ZimmerGEH_HMI.Ausgang.DataTransferError := TRUE;
	        #error_state := 3;
	    END_IF;
	    
	    IF #ton_Timer_InMotion.Q THEN
	        #ZimmerGEH_HMI.Ausgang.MotionError := TRUE;
	        #error_state := 4;
	    END_IF;
	END_REGION
	
	REGION Flankenerkennung
	    // R_TRIG fuer alle Befehle entsprechend HMI-UDT
	    #rtrig_StartHoming(CLK := #ZimmerGEH_HMI.Eingang.StartHoming);
	    #rtrig_DataTransfer(CLK := #ZimmerGEH_HMI.Eingang.DataTransfer);
	    #rtrig_MoveToBase(CLK := #ZimmerGEH_HMI.Eingang.MoveToBase);
	    #rtrig_MoveToWork(CLK := #ZimmerGEH_HMI.Eingang.MoveToWork);
	END_REGION
	
	REGION Eingangsdaten vom Greifer
	    // StatusWord aus DrvToPlc-UDT auslesen
	    #ZimmerGEH_HMI.Ausgang.HomingPositionOK := #i_ZimmerGEH_DrvToPlc.StatusWord.HomingPositionOK;
	    #ZimmerGEH_HMI.Ausgang.MotorON := #i_ZimmerGEH_DrvToPlc.StatusWord.MotorON;
	    #ZimmerGEH_HMI.Ausgang.InMotion := #i_ZimmerGEH_DrvToPlc.StatusWord.InMotion;
	    #ZimmerGEH_HMI.Ausgang.MovementComplete := #i_ZimmerGEH_DrvToPlc.StatusWord.MovementComplete;
	    #ZimmerGEH_HMI.Ausgang.BasePosition := #i_ZimmerGEH_DrvToPlc.StatusWord.BasePosition;
	    #ZimmerGEH_HMI.Ausgang.WorkPosition := #i_ZimmerGEH_DrvToPlc.StatusWord.WorkPosition;
	    #ZimmerGEH_HMI.Ausgang.Error := #i_ZimmerGEH_DrvToPlc.StatusWord.Error;
	    
	    // Weitere Daten aus DrvToPlc-UDT
	    #ZimmerGEH_HMI.Ausgang.Diagnosis := UINT_TO_INT(#i_ZimmerGEH_DrvToPlc.Diagnosis);
	    #ZimmerGEH_HMI.Ausgang.ActualPosition := UINT_TO_INT(#i_ZimmerGEH_DrvToPlc.ActualPosition);
	    
	    // Interne Hilfsmerkbits
	    #hmPower_on := #i_ZimmerGEH_DrvToPlc.StatusWord.MotorON;
	    #gripper_in_motion := #i_ZimmerGEH_DrvToPlc.StatusWord.InMotion;
	    #hmReferenced := #i_ZimmerGEH_DrvToPlc.StatusWord.HomingPositionOK;
	    #hmGripped := #i_ZimmerGEH_DrvToPlc.StatusWord.WorkPosition;
	END_REGION
	
	REGION Reset-Behandlung
	    IF #ZimmerGEH_HMI.Eingang.StepReset OR #i_StoerungQuittieren THEN
	        // Alle Zustandsmaschinen zuruecksetzen
	        #power_on_state := 0;
	        #reference_state := 0;
	        #grip_state := 0;
	        #release_state := 0;
	        #error_state := 0;
	        
	        // Ausgangsstatus zuruecksetzen
	        #ZimmerGEH_HMI.Ausgang.DataTransferError := FALSE;
	        #ZimmerGEH_HMI.Ausgang.MotionError := FALSE;
	        #ZimmerGEH_HMI.Ausgang.StepBusy := FALSE;
	        #ZimmerGEH_HMI.Ausgang.StepDone := TRUE;
	        
	        // ControlWord zuruecksetzen
	        #q_ZimmerGEH_PlcToDrv.ControlWord := 0;
	        
	        // Stoermeldeindikator zuruecksetzen
	        #iq_Stoermeldeindikator := FALSE;
	        
	        #ZimmerGEH_HMI.Ausgang.Status := 'Reset durchgefuehrt';
	    END_IF;
	END_REGION
	
	REGION Power ON Greifer
	    IF #i_NotHalt_IO AND #i_Sicherheitskreis_IO THEN
	        CASE #power_on_state OF
	            0: // S0 Idle - warten auf StartHoming fuer Motor einschalten
	                #ZimmerGEH_HMI.Ausgang.Status := 'Motor Aus - Referenzfahrt erforderlich';
	                IF #rtrig_StartHoming.Q AND #error_state = 0 THEN
	                    #ZimmerGEH_HMI.Ausgang.StepBusy := TRUE;
	                    #ZimmerGEH_HMI.Ausgang.StepDone := FALSE;
	                    #power_on_state := 1;
	                END_IF;
	                
	            1: // Motor einschalten - Reset senden
	                #ZimmerGEH_HMI.Ausgang.Status := 'Greifer Reset';
	                #q_ZimmerGEH_PlcToDrv.DeviceMode := 2; // Greifer-Reset
	                #q_ZimmerGEH_PlcToDrv.ControlWord := 1; // DataTransfer
	                #wthDog(IN := TRUE, PT := T#1s);
	                IF #i_ZimmerGEH_DrvToPlc.StatusWord.DataTransferOK THEN
	                    #q_ZimmerGEH_PlcToDrv.ControlWord := 0;
	                    #wthDog(IN := FALSE, PT := T#1s);
	                    #power_on_state := 2;
	                ELSIF #wthDog.Q THEN
	                    #error_state := 3;
	                    #power_on_state := -1;
	                END_IF;
	                
	            2: // Warten auf Reset-Bestaetigung
	                #ZimmerGEH_HMI.Ausgang.Status := 'Warten auf Reset-Bestaetigung';
	                IF NOT #i_ZimmerGEH_DrvToPlc.StatusWord.DataTransferOK THEN
	                    #power_on_state := 3;
	                END_IF;
	                
	            3: // Motor einschalten
	                #ZimmerGEH_HMI.Ausgang.Status := 'Motor einschalten';
	                #q_ZimmerGEH_PlcToDrv.DeviceMode := 3; // Motor ON
	                #q_ZimmerGEH_PlcToDrv.ControlWord := 1; // DataTransfer
	                #wthDog(IN := TRUE, PT := T#1s);
	                IF #i_ZimmerGEH_DrvToPlc.StatusWord.DataTransferOK THEN
	                    #q_ZimmerGEH_PlcToDrv.ControlWord := 0;
	                    #wthDog(IN := FALSE, PT := T#1s);
	                    #power_on_state := 4;
	                ELSIF #wthDog.Q THEN
	                    #error_state := 3;
	                    #power_on_state := -1;
	                END_IF;
	                
	            4: // Warten auf Motor-ON Bestaetigung
	                #ZimmerGEH_HMI.Ausgang.Status := 'Motor bereit - starte Referenzfahrt';
	                IF NOT #i_ZimmerGEH_DrvToPlc.StatusWord.DataTransferOK THEN
	                    #power_on_state := 5; // Direkt zur Referenzfahrt
	                END_IF;
	                
	            5: // Referenzfahrt automatisch starten
	                #ZimmerGEH_HMI.Ausgang.Status := 'Referenzfahrt starten';
	                #q_ZimmerGEH_PlcToDrv.DeviceMode := 10; // Standard Homing
	                #q_ZimmerGEH_PlcToDrv.ControlWord := 1; // DataTransfer
	                #reference_state := 1; // Referenzfahrt-Zustandsmaschine aktivieren
	                #power_on_state := 100;
	                
	            100: // Motor laeuft - Ueberwachung
	                IF #i_ZimmerGEH_DrvToPlc.StatusWord.Error THEN
	                    #power_on_state := -2;
	                ELSIF #hmReferenced THEN
	                    #ZimmerGEH_HMI.Ausgang.Status := 'Motor Ein - Betriebsbereit';
	                    #ZimmerGEH_HMI.Ausgang.StepBusy := FALSE;
	                    #ZimmerGEH_HMI.Ausgang.StepDone := TRUE;
	                ELSE
	                    #ZimmerGEH_HMI.Ausgang.Status := 'Motor Ein - Referenzfahrt laeuft';
	                END_IF;
	                
	            -1: // Fehler beim Einschalten
	                #ZimmerGEH_HMI.Ausgang.Status := 'Fehler Motor einschalten';
	                #ZimmerGEH_HMI.Ausgang.StepBusy := FALSE;
	                #ZimmerGEH_HMI.Ausgang.StepDone := TRUE;
	                
	            -2: // Stoerung im Betrieb
	                #ZimmerGEH_HMI.Ausgang.Status := 'Stoerung Greifer';
	                #ZimmerGEH_HMI.Ausgang.StepBusy := FALSE;
	                #ZimmerGEH_HMI.Ausgang.StepDone := TRUE;
	        END_CASE;
	    ELSE
	        // Sicherheit nicht OK - Motor ausschalten
	        #power_on_state := 0;
	        #ZimmerGEH_HMI.Ausgang.Status := 'Sicherheitskreis NIO';
	        #q_ZimmerGEH_PlcToDrv.ControlWord := 0;
	    END_IF;
	END_REGION
	
	REGION Referenzfahrt
	    // Referenzfahrt-Zustandsmaschine (laeuft parallel zu Power ON)
	    IF #reference_state > 0 THEN
	        CASE #reference_state OF
	            1: // Warten auf Bestaetigung DataTransfer fuer Homing
	                #wthDog(IN := TRUE, PT := T#2s);
	                IF #i_ZimmerGEH_DrvToPlc.StatusWord.DataTransferOK THEN
	                    #q_ZimmerGEH_PlcToDrv.ControlWord := 0;
	                    #wthDog(IN := FALSE, PT := T#2s);
	                    #reference_state := 2;
	                ELSIF #wthDog.Q THEN
	                    #error_state := 7;
	                    #reference_state := -1;
	                END_IF;
	                
	            2: // Warten auf Referenzfahrt abgeschlossen
	                #wthDog(IN := TRUE, PT := T#30s);
	                IF NOT #i_ZimmerGEH_DrvToPlc.StatusWord.DataTransferOK 
	                    AND #i_ZimmerGEH_DrvToPlc.StatusWord.HomingPositionOK THEN
	                    #wthDog(IN := FALSE, PT := T#30s);
	                    #reference_state := 100;
	                ELSIF #wthDog.Q THEN
	                    #error_state := 7;
	                    #reference_state := -1;
	                END_IF;
	                
	            100: // Referenzfahrt abgeschlossen
	                #ZimmerGEH_HMI.Eingang.StartHoming := FALSE; // Auto-Reset
	                #reference_state := 0;
	                
	            -1: // Fehler
	                #ZimmerGEH_HMI.Ausgang.Status := 'Fehler Referenzfahrt';
	                #reference_state := 0;
	        END_CASE;
	    END_IF;
	END_REGION
	
	REGION Werkstueck Greifen
	    IF #hmPower_on 
	        AND #rtrig_MoveToWork.Q
	        AND #error_state = 0
	        AND #power_on_state = 100
	        AND #i_FreigabeBewegung
	        AND #hmReferenced
	    THEN
	        CASE #grip_state OF
	            0: // Parameter setzen fuer Greifen
	                #ZimmerGEH_HMI.Ausgang.Status := 'Greifen - Parameter setzen';
	                #ZimmerGEH_HMI.Ausgang.StepBusy := TRUE;
	                #ZimmerGEH_HMI.Ausgang.StepDone := FALSE;
	                
	                // Parameter aus HMI-UDT uebernehmen
	                #q_ZimmerGEH_PlcToDrv.DeviceMode := 63; // Aussengreifen
	                #q_ZimmerGEH_PlcToDrv.WorkpieceNo := 0; // Standardwert
	                #q_ZimmerGEH_PlcToDrv.GripForce := INT_TO_BYTE(#ZimmerGEH_HMI.Eingang.GripForce);
	                #q_ZimmerGEH_PlcToDrv.DriveVelocity := INT_TO_BYTE(#ZimmerGEH_HMI.Eingang.DriveVelocity);
	                #q_ZimmerGEH_PlcToDrv.WorkPosition := INT_TO_UINT(#ZimmerGEH_HMI.Eingang.WorkPosition);
	                
	                #q_ZimmerGEH_PlcToDrv.ControlWord := 1; // DataTransfer
	                #grip_state := 1;
	                
	            1: // Warten auf Parameteruebernahme
	                #wthDog(IN := TRUE, PT := T#2s);
	                IF #i_ZimmerGEH_DrvToPlc.StatusWord.DataTransferOK THEN
	                    #q_ZimmerGEH_PlcToDrv.ControlWord := 0;
	                    #wthDog(IN := FALSE, PT := T#2s);
	                    #grip_state := 2;
	                ELSIF #wthDog.Q THEN
	                    #error_state := 3;
	                    #grip_state := -1;
	                END_IF;
	                
	            2: // Bewegung zur WorkPosition starten
	                IF NOT #i_ZimmerGEH_DrvToPlc.StatusWord.DataTransferOK THEN
	                    #ZimmerGEH_HMI.Ausgang.Status := 'Greifen - Fahre zu WorkPosition';
	                    #q_ZimmerGEH_PlcToDrv.ControlWord := 200; // MoveToWork
	                    #gripper_in_motion := TRUE;
	                    #grip_state := 3;
	                END_IF;
	                
	            3: // Warten auf Greifen abgeschlossen
	                #wthDog(IN := TRUE, PT := #ZimmerGEH_HMI.Eingang.MotionTimeout);
	                IF #i_ZimmerGEH_DrvToPlc.StatusWord.WorkPosition 
	                    AND #i_ZimmerGEH_DrvToPlc.StatusWord.MovementComplete THEN
	                    #q_ZimmerGEH_PlcToDrv.ControlWord := 0;
	                    #gripper_in_motion := FALSE;
	                    #wthDog(IN := FALSE, PT := #ZimmerGEH_HMI.Eingang.MotionTimeout);
	                    #grip_state := 100;
	                    #ZimmerGEH_HMI.Ausgang.StepBusy := FALSE;
	                    #ZimmerGEH_HMI.Ausgang.StepDone := TRUE;
	                    #ZimmerGEH_HMI.Ausgang.Status := 'Werkst체ck gegriffen';
	                ELSIF #wthDog.Q THEN
	                    #error_state := 5;
	                    #grip_state := -1;
	                END_IF;
	                
	            100: // Greifen abgeschlossen
	                #ZimmerGEH_HMI.Ausgang.Status := 'Werkstueck gegriffen';
	                #ZimmerGEH_HMI.Eingang.MoveToWork := FALSE; // Auto-Reset
	                #grip_state := 0;
	                
	            -1: // Fehler
	                #ZimmerGEH_HMI.Ausgang.Status := 'Fehler beim Greifen';
	                #q_ZimmerGEH_PlcToDrv.ControlWord := 0;
	                #gripper_in_motion := FALSE;
	                #ZimmerGEH_HMI.Ausgang.StepBusy := FALSE;
	                #ZimmerGEH_HMI.Ausgang.StepDone := TRUE;
	                #grip_state := 0;
	        END_CASE;
	    ELSIF NOT #i_FreigabeBewegung THEN
	        #ZimmerGEH_HMI.Ausgang.Status := 'Bewegung gesperrt';
	    ELSIF NOT #hmReferenced THEN
	        #ZimmerGEH_HMI.Ausgang.Status := 'Nicht referenziert';
	        #error_state := 2;
	    END_IF;
	END_REGION
	
	REGION Werkstueck Loslassen
	    IF #hmPower_on 
	        AND #rtrig_MoveToBase.Q
	        AND #error_state = 0
	        AND #power_on_state = 100
	        AND #i_FreigabeBewegung
	        AND #hmReferenced
	    THEN
	        CASE #release_state OF
            0: // Parameter setzen f체r Loslassen
                #ZimmerGEH_HMI.Ausgang.Status := 'Loslassen - Parameter setzen';
                #ZimmerGEH_HMI.Ausgang.StepBusy := TRUE;
                #ZimmerGEH_HMI.Ausgang.StepDone := FALSE;
                
                // Parameter aus HMI-UDT 체bernehmen
                #q_ZimmerGEH_PlcToDrv.DeviceMode := 62; // Innengreifen (auch fuer Oeffnen)
                #q_ZimmerGEH_PlcToDrv.WorkpieceNo := 0; // Standardwert
                #q_ZimmerGEH_PlcToDrv.GripForce := INT_TO_BYTE(#ZimmerGEH_HMI.Eingang.GripForce);
                #q_ZimmerGEH_PlcToDrv.DriveVelocity := INT_TO_BYTE(#ZimmerGEH_HMI.Eingang.DriveVelocity);
                #q_ZimmerGEH_PlcToDrv.BasePosition := INT_TO_UINT(#ZimmerGEH_HMI.Eingang.BasePosition);	                #q_ZimmerGEH_PlcToDrv.ControlWord := 1; // DataTransfer
	                #release_state := 1;
	                
	            1: // Warten auf Parameteruebernahme
	                #wthDog(IN := TRUE, PT := T#2s);
	                IF #i_ZimmerGEH_DrvToPlc.StatusWord.DataTransferOK THEN
	                    #q_ZimmerGEH_PlcToDrv.ControlWord := 0;
	                    #wthDog(IN := FALSE, PT := T#2s);
	                    #release_state := 2;
	                ELSIF #wthDog.Q THEN
	                    #error_state := 3;
	                    #release_state := -1;
	                END_IF;
	                
	            2: // Bewegung zur BasePosition starten
	                IF NOT #i_ZimmerGEH_DrvToPlc.StatusWord.DataTransferOK THEN
	                    #ZimmerGEH_HMI.Ausgang.Status := 'Loslassen - Fahre zu BasePosition';
	                    #q_ZimmerGEH_PlcToDrv.ControlWord := 100; // MoveToBase
	                    #gripper_in_motion := TRUE;
	                    #release_state := 3;
	                END_IF;
	                
	            3: // Warten auf Loslassen abgeschlossen
	                #wthDog(IN := TRUE, PT := #ZimmerGEH_HMI.Eingang.MotionTimeout);
	                IF #i_ZimmerGEH_DrvToPlc.StatusWord.BasePosition 
	                    AND #i_ZimmerGEH_DrvToPlc.StatusWord.MovementComplete THEN
	                    #q_ZimmerGEH_PlcToDrv.ControlWord := 0;
	                    #gripper_in_motion := FALSE;
	                    #wthDog(IN := FALSE, PT := #ZimmerGEH_HMI.Eingang.MotionTimeout);
	                    #release_state := 100;
	                    #ZimmerGEH_HMI.Ausgang.StepBusy := FALSE;
	                    #ZimmerGEH_HMI.Ausgang.StepDone := TRUE;
	                    #ZimmerGEH_HMI.Ausgang.Status := 'Werkstueck losgelassen';
	                ELSIF #wthDog.Q THEN
	                    #error_state := 6;
	                    #release_state := -1;
	                END_IF;
	                
	            100: // Loslassen abgeschlossen
	                #ZimmerGEH_HMI.Ausgang.Status := 'Werkstueck losgelassen';
	                #ZimmerGEH_HMI.Eingang.MoveToBase := FALSE; // Auto-Reset
	                #release_state := 0;
	                
	            -1: // Fehler
	                #ZimmerGEH_HMI.Ausgang.Status := 'Fehler beim Loslassen';
	                #q_ZimmerGEH_PlcToDrv.ControlWord := 0;
	                #gripper_in_motion := FALSE;
	                #ZimmerGEH_HMI.Ausgang.StepBusy := FALSE;
	                #ZimmerGEH_HMI.Ausgang.StepDone := TRUE;
	                #release_state := 0;
	        END_CASE;
	    END_IF;
	END_REGION
	
	REGION Ausg채nge
	    // Greifer bereit: Motor an, referenziert, kein Fehler
	    #q_GripperReady := #hmPower_on AND #hmReferenced AND #error_state = 0;
	    
	    // HMI Status
	    #ZimmerGEH_HMI.Ausgang.ErrorState := #error_state;
	    
	    // Status-Text setzen wenn nicht spezifisch gesetzt
	    IF #ZimmerGEH_HMI.Ausgang.Status = '' THEN
	        IF #error_state > 0 THEN
	            #ZimmerGEH_HMI.Ausgang.Status := 'Fehler aktiv';
	        ELSIF NOT #hmPower_on THEN
	            #ZimmerGEH_HMI.Ausgang.Status := 'Motor aus';
	        ELSIF NOT #hmReferenced THEN
	            #ZimmerGEH_HMI.Ausgang.Status := 'Nicht referenziert';
	        ELSE
	            #ZimmerGEH_HMI.Ausgang.Status := 'Bereit';
	        END_IF;
	    END_IF;
	END_REGION
	
	REGION Fehlerhandling ZimmerGEH
	    #iDB_BasisMappingProgramAlarm
	    (i_Signal := #i_ZimmerGEH_DrvToPlc.StatusWord.Error OR #error_state <> 0,
	     i_Maschine := #ip_Maschine,
	     i_Station := #ip_Station,
	     i_Bmk := #ip_Bmk,
	     i_FehlernummerObjekt := #error_state,
	     i_IstWarnung := FALSE,
	     iq_Meldung := #Meldungen_ZimmerGEH);
	    
	    // Ausgabe bei Stoerung
	    IF #iDB_BasisMappingProgramAlarm.q_Stoerung THEN
	        #iq_Stoermeldeindikator := #iDB_BasisMappingProgramAlarm.q_Stoerung OR #iq_Stoermeldeindikator;
	        // Alle Bewegungsbefehle zuruecksetzen bei Stoerung
	        #ZimmerGEH_HMI.Eingang.StartHoming := FALSE;
	        #ZimmerGEH_HMI.Eingang.MoveToBase := FALSE;
	        #ZimmerGEH_HMI.Eingang.MoveToWork := FALSE;
	        #ZimmerGEH_HMI.Eingang.DataTransfer := FALSE;
	    END_IF;
	END_REGION
	
END_FUNCTION_BLOCK
