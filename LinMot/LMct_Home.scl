FUNCTION_BLOCK "LMct_Home"
TITLE = LMct_Home
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : fj
//This function block commands the axis to perform the «search home» sequence. The details of this sequence are manufacturer dependent and can be set by the axis’ parameters.
   VAR_INPUT 
      Execute : Bool;   // Execute command
   END_VAR

   VAR_OUTPUT 
      Done : Bool;   // Command has been executed
      Busy : Bool;   // Command running / FB Busy
      CommandAborted : Bool;   // Command is aborted by another command
      Error : Bool;   // Error detected
      ErrorID : UInt;   // Error ID:01h: Axis not ready 02h: Axis already has command running 03h: Axis has error 04h: Command interrupted 05h: Command aborted06h: Invalid input(s)
   END_VAR

   VAR_IN_OUT 
      Axis : "tstLM_Axis";   // Axis reference
   END_VAR

   VAR 
      usiOldCmdCount { ExternalVisible := 'False'} : USInt;   // internal ->
      usiNewCmdCount { ExternalVisible := 'False'; ExternalWritable := 'False'} : USInt;   // internal ->
      uiCState { ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // internal ->
      uiFbState { ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt;   // internal ->
      rTrig {InstructionName := 'R_TRIG'; LibVersion := '1.0'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : R_TRIG;   // internal ->
      udiTmpDWord { ExternalVisible := 'False'; ExternalWritable := 'False'} : UDInt;   // internal ->
      uiCmdHeader { ExternalVisible := 'False'; ExternalWritable := 'False'} : UInt := 16#0000;   // CommandHeader (000xh) of the "No Operation (000xh)" motion command
   END_VAR


BEGIN
	(*Variablen ][ variables*)
	#usiOldCmdCount := SHR(IN:=UINT_TO_USINT(SHL(IN:=#Axis.DrvToPlc.StateVar, N:=4)), N:=4);
	#uiCState := SHR(IN:=#Axis.DrvToPlc.StateVar, N:=8);
	
	(*Interrupt / Abort detection*)
	IF #Busy THEN
	    IF NOT (#uiCState = 16#08 OR #uiCState = 16#09) THEN
	        #uiFbState := 50; (*Error state*)
	        #Error := TRUE;
	        IF #uiCState = 16#04 THEN
	            #ErrorID := 16#03; (*Axis has error*)
	        ELSE
	            #ErrorID := 16#04; (*Command interupted*)
	        END_IF;
	    ELSIF NOT #Error AND (#Axis.CommandAborted OR (#Axis.PlcToDrv.MCHeader <> #uiCmdHeader + #usiNewCmdCount)) THEN
	        #uiFbState := 60; (*Command aborted*)
	    END_IF;
	END_IF;
	
	(*Flankenerkennung am Execute Eingang*)
	(*Edge detection on Execute input*)
	#rTrig(CLK := #Execute);
	IF #rTrig.Q THEN
	    IF #uiCState = 16#08 THEN (*Start command*)
	        #Busy := TRUE;
	        #uiFbState := 1;
	    ELSIF #Busy THEN (*Restart command / New rising edge on execute input*)
	        #Busy := TRUE;
	        #uiFbState := 1;
	    END_IF;
	    
	    IF #uiCState <> 16#08 OR (#Axis.AxisState = 4 (*Stopping_LM*)) THEN (*Axis not ready or in stopping state*)
	        #uiFbState := 50; (*Error state*)
	        #Error := TRUE;
	        IF #uiCState = 16#04 THEN
	            #ErrorID := 16#03; (*Axis has error*)
	        ELSE
	            #ErrorID := 16#01; (*Axis not ready*)
	        END_IF;
	    END_IF;
	END_IF;
	
	(*State machine*)
	CASE #uiFbState OF
	    0:
	        ;
	        
	    1:
	        #Axis.AxisState := 5; //Homing_LM; // Set MC state
	        
	        (*Set Home Bit*)
	        #Axis.PlcToDrv.ControlWord.%X11 := TRUE;
	        #Axis.Status.Homed := FALSE;
	        
	        #Axis.PlcToDrv.MCHeader := 16#0000; (*Reset Header*)
	
	        #uiFbState := 2;
	        
	    2:  (*Prüfen ob Befehl ausgeführt ][ Check if command has been executed*)
	        IF #Axis.DrvToPlc.StateVar = 16#090F THEN
	            #Axis.PlcToDrv.ControlWord.%X11 := FALSE;
	            #uiFbState := 3;
	        END_IF;
	        
	    3: (* Check if state is Operation Enabled*)
	        IF #uiCState = 16#08 THEN
	            #Done := TRUE;
	            #Busy := FALSE;
	            #Axis.AxisState := 2; //Standstill_LM;
	            #uiFbState := 4;
	        END_IF;
	        
	    4:
	        IF NOT #Execute THEN
	            #uiFbState := 0;
	            #Busy := FALSE;
	            #Done := FALSE;
	        END_IF;
	        
	    50:
	        #Error := TRUE;
	        #Busy := FALSE;
	        #Done := FALSE;
	        #Axis.PlcToDrv.ControlWord.%X11 := FALSE;
	        IF NOT #Execute THEN
	            #uiFbState := 0;
	            #Error := FALSE;
	            #ErrorID := 0;
	        END_IF;
	        
	    60:
	        #CommandAborted := TRUE;
	        #Axis.PlcToDrv.ControlWord.%X11 := FALSE;
	        #Error := FALSE;
	        #Busy := FALSE;
	        #Done := FALSE;
	        IF NOT #Execute THEN
	            #uiFbState := 0;
	            #CommandAborted := FALSE;
	        END_IF;
	        
	    ELSE
	        ;
	END_CASE;
END_FUNCTION_BLOCK

